<p>
	<img alt="" src="http://chart.apis.google.com/chart?chxt=x,y&amp;chco=FFF804,336699,339933,ff0000,cc99cc,cf5910&amp;chf=bg,s,FFFFFF&amp;chd=t:10000,50000,100000,250000,500000,750000,1000000,1250000,1500000,2000000,3000000,4000000,5000000|0.0002803,0.00031021,0.00031897999999999996,0.00052032,0.03459937,0.00123087,0.06349645,0.07845684,0.09324531999999999,0.12280907,0.18330439,0.24040959999999997,0.29858604|10000,50000,100000,250000,500000,750000,1000000,1250000,1500000,2000000,3000000,4000000,5000000|0.00032878,0.00019433999999999999,0.00020201,0.00020956,0.00025494,0.00026746,0.00026342,0.00028251999999999997,0.00027456,0.00027869,0.00028462999999999996,0.00029079,0.00029082999999999995|10000,50000,100000,250000,500000,750000,1000000,1250000,1500000,2000000,3000000,4000000,5000000|0.00254504,0.011926609999999999,0.0345276,0.08135645999999999,0.17060777,0.35290446000000003,0.6773643699999999,0.95111547,1.3249541100000002,1.61107401,2.6634913499999997,3.5303438099999997,4.50697092|10000,50000,100000,250000,500000,750000,1000000,1250000,1500000,2000000,3000000,4000000,5000000|0.019872710000000002,0.10239209,0.18149404,0.6865259499999999,1.78321902,2.79223724,3.6590724400000005,4.7298564,6.909563979999999,8.296083770000001,20.483684759999996,23.943202569999997,29.41751859|10000,50000,100000,250000,500000,750000,1000000,1250000,1500000,2000000,3000000,4000000,5000000|0.00030773,0.00020784000000000002,0.00020991,0.0002129,0.00027568000000000004,0.0002713,0.00027557,0.00027228,0.00028159,0.00028781,0.00028321,0.00028975,0.00027979000000000003&amp;chds=a&amp;chdl=%3C%3C|shift|unshift|add|pop&amp;chtt=Ruby+Array+Operation+Speed&amp;cht=lxy&amp;chs=400x300&amp;chxr=0,10000,5000000|1,0.0002803,0.29858604|2,10000,5000000|3,0.00032878,0.00032878|4,10000,5000000|5,0.00254504,4.50697092|6,10000,5000000|7,0.019872710000000002,29.41751859|8,10000,5000000|9,0.00030773,0.00030773" /></p>
<p>
	The above chart summarizes the amortized performance of various ruby array operations. It shows that add (array concatenation), &#39;&lt;&lt;&#39; (append), and unshift are linear time, while pop and shift are O(1). It&#39;s interesting to note that like pop, shift is also implemented in a way that doesn&#39;t require the array to be copied. This might lead one to expect that shifting and then unshifting would be a cheaper operation than just unshifting (because by shifting first, we make room for the unshifted element, meaning no array copy is needed), but this isn&#39;t the case in ruby 1.9.2:</p>
<p>
	<img alt="" src="http://chart.apis.google.com/chart?chxt=x&amp;chco=FFF804,336699,339933,ff0000,cc99cc,cf5910&amp;chf=bg,s,FFFFFF&amp;chd=t:10000,50000,100000,250000,500000,750000,1000000,1250000,1500000,2000000,3000000,4000000,5000000|0.00093941,0.00034843,0.00033227,0.00029911,0.00036762,0.00027479,0.00028683,0.0002947,0.00028031999999999997,0.00031613999999999996,0.00031037,0.00030654,0.00031412|10000,50000,100000,250000,500000,750000,1000000,1250000,1500000,2000000,3000000,4000000,5000000|0.00251961,0.014802140000000002,0.034176769999999995,0.08120873,0.16741197999999996,0.44621946,0.6591284000000001,0.9481838099999998,1.2704872,1.79704384,2.73875158,3.70522418,4.56115743|10000,50000,100000,250000,500000,750000,1000000,1250000,1500000,2000000,3000000,4000000,5000000|0.00496242,0.07087493,0.27516400999999996,1.1739664900000002,2.66260044,4.35672739,6.03405298,8.25012411,9.883580779999999,14.96015715,22.459380069999998,29.939172,37.15060023&amp;chds=a&amp;chdl=shift|unshift|shift+then+unshift&amp;chtt=Ruby+Array+Operation+Speed&amp;cht=lxy&amp;chs=300x200&amp;chxr=0,10000,5000000|1,0.00093941,0.00093941|2,10000,5000000|3,0.00251961,4.56115743|4,10000,5000000|5,0.00496242,37.15060023" style="width: 300px; height: 200px; " /></p>
<p>
	&#39;&lt;&lt;&#39; (append) is <em>much</em> cheaper than array concatenation using &#39;+&#39;, but is still linear time when operating on a newly initialized large array, because at least one array copy is required to allocate more space.</p>
<p>
	<img alt="" src="http://chart.apis.google.com/chart?chxt=x&amp;chco=FFF804,336699,339933,ff0000,cc99cc,cf5910&amp;chf=bg,s,FFFFFF&amp;chd=t:10000,50000,100000,250000,500000,750000,1000000,1250000,1500000,2000000,3000000,4000000,5000000|0.0007417199999999999,0.0010325100000000002,0.0012542500000000002,0.00164358,0.03580288,0.0012277800000000001,0.06376,0.0919179,0.09451032,0.12317876,0.18100484000000003,0.24153253,0.30094287999999997|10000,50000,100000,250000,500000,750000,1000000,1250000,1500000,2000000,3000000,4000000,5000000|0.01703788,0.09264721,0.27533714,0.68005083,1.6319206700000002,2.84837693,4.2630940299999995,6.217405769999999,6.105008389999999,10.9470551,17.02572343,23.28285974,41.95423169&amp;chds=a&amp;chdl=%3C%3C|add&amp;chtt=Ruby+Array+Operation+Speed&amp;cht=lxy&amp;chs=300x200&amp;chxr=0,10000,5000000|1,0.0007417199999999999,0.30094287999999997|2,10000,5000000|3,0.01703788,41.95423169" style="width: 300px; height: 200px; " /></p>
<p>
	However, the amortized time of appending N elements to an empty array is O(1).</p>
<p>
	Here&#39;s the code I used for this:</p>
<pre class="brush: ruby">
def benchmark(samples, sizes)
  results = []
  for n in sizes
    array = Array.new(n,1)
    start = Time.now
    samples.times{ yield array }
    results &lt;&lt; (Time.now - start)*1000/samples
  end
  results
end

samples = 100
sizes = [10_000, 50_000, 100_000, 250_000, 500_000, 750_000, 1_000_000, 1_250_000, 1_500_000, 2_000_000, 3_000_000, 4_000_000, 5_000_000]

results = {}
results[&#39;&lt;&lt;&#39;] = benchmark(samples, sizes) {|array| array &lt;&lt; 1}
#results[&#39;shift&#39;] = benchmark(samples,sizes) {|array| array.shift}
results[&#39;unshift&#39;] = benchmark(samples,sizes) {|array| array.unshift(1)}
#results[&#39;shift then unshift&#39;] = benchmark(samples,sizes) do |array|
#  array.shift
#  array.unshift(1)
#end
#results[&#39;add&#39;] = benchmark(samples,sizes) {|array| array + [1]}
#results[&#39;pop&#39;] = benchmark(samples,sizes) {|array| array.pop}

data = []
for key in results.keys
  data &lt;&lt; sizes
  data &lt;&lt; results[key]
end

require &#39;googlecharts&#39;
puts Gchart.line_xy( :theme =&gt; :thirty7signals,
                      :title =&gt; &#39;Ruby Array Operation Speed&#39;,
                      :data =&gt; data,
                      :axis_with_labels =&gt; &#39;x&#39;,
                      :legend =&gt; results.keys,
                      :encoding =&gt; &#39;text&#39;,
                      :max_value =&gt; &#39;false&#39;
                     ).sub!(&#39;chds=,&#39;, &#39;chds=a&#39;)
</pre>
<p>
	&nbsp;</p>

